package 代码库.笔试为主.栈和队列;


import java.util.Stack;

/*
有一个直方图，用一个整数数组表示，其中每列的宽度为1，
求所给直方图包含的最大矩形面积。比如，对于直方图[2,7,9,4],
它所包含的最大矩形的面积为14(即[7,9]包涵的7x2的矩形)。

给定一个直方图A及它的总宽度n，请返回最大矩形面积。
保证直方图宽度小于等于500。保证结果在int范围内。
测试样例：[2,7,9,4,1],5    返回：14
 */
public class 单调栈_直方图内最大矩形 {
    public static void main(String[] args) {
        int [] a={123,91,771,113,333,215,438,667,460,510,220,532,536,55,162,158,692,435,586,96,11,815,603,695,431,221,835,125,32,38,415,440,1,177,364,132,587,414,576,133,837,514,663,134,428,706,158,581,239,650,814,140,16,93,160,210,202,767,21,782,812,96,220,10,164,793,536,391,84,103,730,526,197,653,642,300,513,510,527,481,627,387,160,225,314,751,161,385,657,847,199,276,124,290,677,350,785,302,814,252,346,295,138,719,262,604,781,355,729,715,402,748,730,503,508,373,144,791,480,205,588,103,471,699,640,755,139,647,357,331,754,563,8,308,548,586,589,272,192,60,703,846,601,170,695,201,400,765,230,516,148,153,267,127,21,703,755,248,535,68,56,728,712,826,70,169,551,619,446,824,678,595,79,61,496,109,579,813,528,277,298,31,600,266,814,246,47,501,295,683,612,186,701,483,220,614,345,278,161,113,256,76,57,387,600,549,698,336,669,689,793,125,203,378,404,307,570,747,89,715,404,125,16,536,627,261,572,218,280,714,410,572,282,812,11,464};
        int res=countArea(a,a.length);
//        int [] b={2,7,9,4,1,5,8,6,15,4,2,7};
//        int res2=countArea(b,b.length);
    }
    public static int countArea(int[] A, int n) {
        Stack<Integer> s = new Stack<>();
        int[] left = new int[n];//左边可到达的位数
        int[] right = new int[n];//右边可到达的位数
        int max=0;
        for(int i=0;i<n;i++){
            while (!s.empty()&&A[i]<=A[s.peek()]){//单调栈，比栈顶的值大压栈，小于等于出栈。
                s.pop();
            }
            if (!s.empty()){//栈不为空时，左移位数为当前下标和栈中下一个的下标只差
                left[i]=i-s.peek()-1;
            }else {
                left[i]=i;//为空，即下面没有值，向左可到底，就是下标
            }
            s.push(i);
        }
        int [] B=new int [n];//这里是将A翻转，用和之前类似的方法。
        for (int i=0;i<n;i++){
            B[i]=A[n-1-i];
        }
        while (!s.empty()){
            s.pop();
        }
        for (int i=0;i<n;i++ ){
            while (!s.empty()&&B[i]<=B[s.peek()]){
                s.pop();
            }
            if (!s.empty()){
                right[n-1-i]=i-s.peek()-1;//注意right的下标就行
            }else {
                right[n-1-i]=i;
            }
            s.push(i);
        };
        for (int i=0;i<n;i++){//每一个的值为，向左扩展和向右扩展家伙再加上自己，乘以数值。再取最大值
            max=Math.max((left[i]+right[i]+1)*A[i],max);
        }
        return max;
    }
    public  int countArea2(int[] A, int n) {
        int max=0;
        for (int i=0;i<n;i++){
            int left=i;
            int right=i;
            while (left>=0&&A[left]>=A[i]){
                left--;
            }
            while (right<n&&A[right]>=A[i]){
                right++;
            }
            if ((right-left-1)*A[i]>max){
                max=(right-left-1)*A[i];
            }
        }
        return max;
    }

}
